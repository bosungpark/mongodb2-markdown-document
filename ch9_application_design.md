Application Design
=

Schema design considerations
-
데이터를 보여주는 핵심은 바로 스키마의 디자인이다.
최선은 어플리케이션에서 데이터를 보여주기 바라는 방식대로 스키마를 디자인하는 것이다. 이렇게하기위해서는 스키마를 짜기 이전에 먼저 쿼리의 방식과 데이터 접근 패턴을 이해하는 것이 중요하다.

아래는 몇가지 고려할 사항들이다.

1. Constraints: 제약사항을 고려해야할 필요가 있다. 몽고에서 도큐먼트는 최대 16MB이다. 
2. Access patterns of your queries and of your writes: 워크로드를 파악하고 계량화할 필요가 있다. 워크로드가 크게 몰리는 쿼리일 수록 세심한 설계가 필요하다. 함께 많이 사용하는 데이터를 묶고 그렇지 않은 데이터를 분리한다.
3. Relation types: 도큐먼트들 사이의 관계도 고려할 필요가 있다. 이에 따라 임베드를 할지 레퍼런싱을 할 지 결정할 수 있다. 
4. Cardinality

아래는 몇가지 대표적인 디자인 패턴이다.

1. Polymorphic pattern: 컬렉션의 도큐먼트들이 유사하나 동일하지는 않은 경우 사용할 수 있는 패턴. 어플리케이션 단에서 쿼리할 수 있는 공통부분을 추출하고, 차이점을 가질 수 있는 필드를 특정하는 방식. 
2. Attribute pattern: 쿼리 혹은 정렬할 데이터중에 공통적인 부분이 있는 경우 사용하는 패턴. 어레이에 키와 값의 쌍을 가진 데이터를 만들고, 이 어레이에 인덱스를 거는 방식이다. 
3. Bucket pattern: 스트림에서 일정 기간동안 쌓이는 시계열 데이터에 유용한 패턴. 매 번 새로운 도큐먼트를 생성하는 것보다, 일정 시간에 해당하는 데이터를 특정 도큐먼트에 밀어넣는 방식이다. 
4. Outlier pattern: 인스타 셀럽과 같이 특정한 도큐먼트가 특이한 행동을 보일 때 사용하는 패턴. Outlier를 의미하는 플래그를 세우고 오버플로우에 대비한다.
5. Computed pattern: 데이터의 연산이 잦거나 read-intensive할 경우 사용하는 패턴이다. 이 패턴은 도큐먼트의 연산을 백그라운드에서 하며 주기적으로 업데이트 할 것을 권장한다. 
6. Subset pattern: RAM을 넘어서는 작업량이 있을 때 사용하는 패턴. 자주 사용하는 데이터와 그렇지 않은 데이터를 분리할 것을 제안. 
7. Extended Reference pattern: 각자 컬렉션을 가지는 논리적 엔티티가 너무 많고 이들을 모아 보여주기를 원할 때, 수많은 쿼리를 날리는 것이 성능에 문제를 줄 경우 사용할 수 있는 패턴. 자주 사용하는 것을 중복하여 다른 엔티티에 임베드하는 방식. 
8. Approximation pattern: resource-expensive한 연산이 요구되는 경우 사용할 수 있는 패턴. 연산은 필요하지만 정확할 필요까지는 없다면 사용할 수 있는 패턴으로 '좋아요 수'를 업데이트 하는 경우, 느슨하게 100개 단위로 업데이트 한다 등의 정책을 예로 들 수 있다.
9. Tree pattern: 계층화된 데이터를 가진 경우 사용할 수 있는 패턴. 몽고에서는 계층화된 데이터를 어레이속에 쉽게 쌓을 수 있다. 
10. Preallocation pattern: 나중에 채울 스트럭쳐를 미리 만들 것을 제안한다. 
11. Document Versioning pattern: 도큐먼트의 버전을 트래킹하는 패턴.

정규화와 반정규화
-
이 둘은 항상 언급되듯, 트레이드-오프관계..
너무 뻔한 이야기라 생략...

Cardinality
-
일반적으로 RDB에서는 일대다와 같이 many의 개념을 가진다.
하지만 몽고는 many를 many와 few로 나누어 생각할 수 있다.
이렇게 한 번 더 나누는 생각은 임베드와 레퍼런스를 구분짓는데에 도움을 줄 수 있다.

Optimizations for Data Manipulation
-
읽기의 최적화는 대부분의 경우 적절한 인덱싱과 적절한 양의 데이터 반환을 통해 이루어진다.

쓰기 연산의 최적화는 대부분 인덱스의 수를 필요한 범위 안에서 최소화하면서 효율적인 쓰기를 하는 것을 통해 이루어진다.

일반적으로 쓰기와 읽기 사이에는 트레이드-오프 관계가 존재한다.

오래된 데이터를 삭제하라. 일부 데이터는 특정시기에만 유효하고, 이후에는 스토리지만 차지하는 경우가 있다. capped collections, TTL(time to live) 혹은 일정 주기마다 데이터를 비워주는 방식을 통해 관리할 필요가 있다.

Planning Out Databases and Collections
-
일반적으로 유사한 스키마를 가지는 도큐먼트는 같은 컬렉션에 저장한다. 비록 모양이 조금 다르더라도 함께 집계되야 할 필요가 있다면 같은 컬렉션에 넣는 것이 좋다.

Managing Consistency
-
몽고는 다양한 정도의 동시성 제어(read your own write 등)를 제공한다.

이렇게 다양한 수준의 제어가 가능한 이유는 몽고 내부에서 컬렉션마다 요청에 대한 큐를 가지고 있기 때문이다. 새로운 요청이 들어오면 큐의 뒷편에 쌓일테니 하나의 커넥션에 대해서는 read your own write가 보장된다.

하지만 큐는 커넥션마다 생성된다는 점에 주의해야한다. 

When Not to Use MongoDB
-

1. 여러 차원의 다양한 데이터를 조인해야하는 경우
2. 지원하는 툴이 없는 경우
