Configuring Sharding
=

RAM, disk space, load를 줄이거나 하나 이상의 mongod가 감당할 수 있는 데이터를 처리해야하는 경우 샤딩을 고려할 수 있다.
mongos, shards, config server가 마련되었다면 샤딩을 시도해 볼 수 있다.

Config Servers
-
config server는 클러스터의 두뇌에 비유할 수 있다. 각각에 서버가 가지고 있는 메타데이터에 대한 정보를 들고 있다.
이런 정보는 중요하므로 반드시 영구 데이터 저장소에 journaling과 함께 사용되어야 한다.
또 프로덕션이라면 적어도 3개 이상의 레플리카 셋에 (가능하면 지리적으로 분리되어) 함께 운용하는 것이 좋다.
mongos는 설정값을 얻어와야하므로 config server가 세팅된 후에 시작할 수 있다.
일련의 과정을 통해 mongos가 세팅되었다면, config 혹은 admin 데이터베이스를 통해 쓰기연산을 수행할 수 있다.
config 데이터베이스는 샤딩에 대한 메타데이터를 admin는 인증과 인가와 관련한 역할을 한다.

The mongos Processes
-
mongos를 사용할 때에는 --configdb 옵션과 함께 사용하는 것이 좋고, 각각의 프로세스는 적은 수를 유지하면 지리적으로 가까운 샤드로 시작하는 것이 좋다.

Adding a Shard from a Replica Set
-
기존에 존재하는 레플리카 셋에 샤딩을 적용하기 위해서는 모든 레플리케 셋에 --shardsvr 옵션을 적용해주어야 한다.

Sharding Data
-
샤딩을 하는 방법을 알려주지 않는한 몽고는 스스로 샤딩을 하지는 않는다.
샤딩을 한다는 것은 반드시 컬렉션 중 하나를 샤딩한다는 것이 전제조건이다.
또 샤딩을 하고자하는 컬렉션은 반드시 인덱싱된 상태여야 한다.
만약 존재하지 않는 컬렉션이라면 몽고가 만들어 인덱스를 걸어줄 것이다.
샤딩의 기본적인 원리는 인덱싱과 같다.
따라서 만약 컴파운드 키를 건다면, 인덱싱을 할 때에 컴파운드 정렬과 비슷하게 생각하면 된다.

How MongoDB Tracks Cluster Data
-
이미 존재하는 컬렉션을 샤딩한다면 밸런싱에 시간이 걸릴 수 있다.
각각의 mongos는 shard key를 사용하여 찾고지 하는 데이터의 위치를 알아야한다.
한 컬렉션이 가진 모든 도큐먼트의 수는 너무 많기 때문에 청크에 단위를 사용하여 1차로 나누고 한 청크는 한 샤드 안에 배치한다.
단 쓰기 연산이 일어날 때, 한 청크 안에 도큐먼트의 수는 변할 수 있다.
예를 들어 나이를 키로 정한 컬렉션에서 20살인 사람만 입력된다면 특정 샤드에 도큐먼트가 몰릴 수 있다.
이런 현상을 예방하기 위해 몽고는 특정 사이즈가 넘은 샤드는 작은 청크로 분할한다.
청크를 분할하면 샤드가 커버하는 데이터 범위를 유지하며 탐색에 유리한 단위를 가져갈 수 있다.
하지만 청크가 서로 중첩되게 분할해서는 안된다. (예: 1-30, 20-40 -> X)
또 하나의 도큐먼트는 반드시 하나의 청크에만 위치해야 한다. (키를 어레이 타입의 필드로 잡으면 인덱스의 진입접이 흩어지며 재양이 일어날 수 있다.)

Chunk Ranges
-
모든 청크는 데이터의 범위로 구분된다.
최초로 생성된 샤드에는 하나의 청크만이 존재하며, 청크의 범위는 음/양의 범위로 무한하다.
데이테의 크기가 커지는 특정 시기(split point)가 되면 자동으로 청크가 분할된다.
청크에 대한 정보는  config.chunks 컬렉션에 저장된다.

Splitting Chunks
-
각각 샤드의 shard primary mongod는 가장 최근 청크를 트랙킹하다가 임계점에 다다르면 쪼갠다.
쪼개는 시점에 몽고는 global chunk size configuration를 참조하며 config servers에 업데이트 사항을 기록한다.
또 만약 쪼개진 청크가 레인지의 탑이라면 특정 샤드가 과열되는 것을 방지하기 위해 다른 샤드로 이동된다.

또 제한된 방법이지만 split point가 오기 전에 키가 되는 필드를 수정하여 인위적으로 청크를 옯기는 방법도 있다.
(같은 키를 가진 도큐먼트는 반드시 같은 청크에 위치하므로)
이는 반대로 말하면 같은 키를 가진 데이터가 무수히 많다면, 이 데이터를 다른 청크로 나눌 수 없다는 뜻이기도 하다.

config servers 중 하나가 죽었다면, 청크의 분할은 불가능한데 이때 지속적으로 재시도하는 현상을 split storm이라고 한다.

The Balancer
-
balancer는 데이터의 마이그레이션에 사용된다.
config server 레플리카의 프라이머리에서 일어나는 백그라운드 프로세스로 샤드들의 청크를 모니터링한다.
만약 샤드들 사이에 불균등함을 탐지하면 균등하게 만들어주는 역할을 한다.

Collations
-
Collations은 몽고에서 문자열을 정렬하는 기준을 조작하는 방법을 의미한다.
