Indexes
=

인덱스를 사용하지 않는 쿼리는 전체 컬렉션을 스캔해야하므로 컬렉션 스캔이라고 한다.

몽고의 경우 임베드된 서브 도큐먼트에도 인덱스를 걸 수 있지만, 서브 도큐먼트 자체에 거는 것과 서브 도큐먼트의 특정 필드에 거는 것은 완전히 다르므로 주의해야 한다.

Compound Indexes
-
2개 이상의 키에 대해 걸어야하는 요구사항이 있을 때, 사용하는 인덱스이다.
인덱스의 본질은 결국 정렬이다. 그렇기 때문에 당연하게도 인덱스의 키가 정렬조건의 선두에 위치할 때 관련한 정렬이 빠른 부수적인 효과를 누릴 수 있는 것이다. 

예를 들어 다음과 같은 경우에는 인덱스의 효과를 볼 수 없다.

인덱스: 이름
정렬조건: 나이, 이름

위와 같은 경우 효과를 보기 위해서는 다음과 같이 인덱스를 수정해야한다.

인덱스: 나이, 이름

위의 수정된 인덱스와 같이 다수의 키와 관계한 인덱스를 컴파운드 인덱스라고 한다.
위의 경우 나이의 경우 오름차순 정렬이 되고, 같은 나이 안에 걸리는 이름들 역시 그 안에서는 오름차순을 유지한다.

쿼리의 정렬조건이 다수의 키와 관계가 있는 경우, 혹은 다수의 키와 관계한 쿼리가 필요한 경우 잘 사용하면 효과가 있다. 특히 효율적이고 대표적인 3가지 경우를 소개한다.

1. 나이(선두 키)가 등치조건, 이름이 정렬조건인 경우.
2. 나이(선두 키)가 range query이고 이름이 정렬조건인 경우. 몽고는 인덱스 선두 키를 사용할 수 있다. 만약 정렬조건이 이름이 아니라면 메모리에서의 추가적인 정렬이 필요하고, 32 MB가 넘는 데이터를 처리해야한다면 에러를 반환한다.
3. 이름과, 나이가 등치조건인 경우. 순서가 뒤바뀌더라도 몽고는 인덱스의 엔트리를 찾아 들어갈 것이다.

How MongoDB Selects an Index (쿼리 플랜과 쿼리의 형태)
-
여러 인덱스가 달린 컬렉션에서 몽고는 어떻게 적절한 인덱스의 엔트리를 찾아낼까?

우선 몽고는 쿼리의 형태를 확인한다. 몽고는 어떤 필드를 조회할지, 정렬이 있는지와 같은 것을 확인한다. 이 결과를 토대로 몇가지 적절할지 모를 후보를 추린다.

후보가 정해지면 쿼리 플랜을 생성한다. 그리고 후보 들을 병렬적으로 돌려 성능을 확인한다. 그리고 이렇게 선택된 인덱스는 이후 같은 형태를 가진 쿼리에 사용된다. 서버는 쿼리플랜의 캐시를 유지하고 있는다. 언젠가 컬렉션 혹은 인덱스가 변하거나, mongod가 재실행될 때 쿼리플랜은 캐시에서 사라진다.

컴파운드 인덱스 디자인
-
인덱스를 사용할 때 선택도(Cardinality/Total Number Of Records, 1에 가까울 수록 유니크하다는 특성)를 고려해야 한다. 당연히 선택도가 좋지 않으면 인덱스를 타도 스캔을 많이 해야하니 안좋다.

인덱스 설계시 크게 영향을 미치는 요소는 선택도, 인-메모리 정렬 여부 등이 있을 수 있다. 아래는 추가적인 디자인의 고려요소이다.

1. 등치조건에 걸리는 키는 인덱스 선두에 위치해야 한다.
2. 정렬조건에 걸리는 키는 결과 값으로 multi-value(예: range 쿼리)를 가지는 키의 앞에 위치해야 한다.
3. 결과값으로 multi-value(예: range 쿼리)를 가지는 키는 마지막에 위치해야 한다.
4. 2가지 이상의 조건으로 정렬을 할 때는 인덱스의 차순을 결정해야 할 수 있다. 1가지 조건으로 정렬을 할 때에는 몽고가 알아서 해준다.
5. 인덱스가 걸린 필드만을 조회해야 할 때에는 covered queries를 사용하여 효율적인 쿼리를 할 수도 있다. 인덱스에 걸린 쿼리만을 사용하도록 강제하기 위해서는 프로젝션을 사용할 수 있다.
6. 컴파운드 인덱스를 사용한다는 것은 결국 정렬조건이 여러 개인 인덱스를 만든다는 것. 즉, 의도하지 않더라도 prefix에 해당하는 조합에 대한 인덱싱이 됨을 의미한다.


인덱싱에 비효율적인 연산자
-
\$ne는 일반적으로 인덱싱에 비효율적이다. 이유는 \$ne를 사용하면 인덱스의 엔트리 포인트를 찾을 때, \$ne에 해당하는 필드를 제외한 모든 인덱스를 스캔해야하기 때문이다. 극단적으로 \$ne에 해당하는 필드가 절대 다수라면 효과를 볼 수도 있겠지만, 대부분은 그렇지 못하다.

\$not 역시 때때로는 인덱스를 탈 수도 있지만, 그렇지 못할 때도 많다. range 쿼리는 예외이지만, 이 외의 대부분의 쿼리에 \$not이 걸리면 테이블 스캔을 해야한다.

이런 연산자를 쓸 바에는, 인덱스를 탈 수 있는 다른 방식을 고민하는 것이 좋다.

range 쿼리를 사용할 때에는, 앞서 반복하여 언급했듯, 등치조건을 앞에 범위조건을 뒤에 해서 인덱스를 걸어야한다. 그래야 한번 태워 원하는 결과를 쓸어서 가져올 수 있다.

일반적으로 쿼리를 할 때에는 쿼리 하나에 인덱스 하나이다. 만약 a필드에 인덱스를 걸고 b필드에 인덱스를 건 뒤, a와 b에 등치조건으로 쿼리를 해도 인덱스는 둘 중 하나만 탄다는 의미이다. 예외가 있다면 \$or절을 사용할 때 이다. \$or 연산자는 각각의 쿼리를 한 뒤 결과를 중복을 제거한 뒤에 합쳐 보여주는 연산자이다. 하지만 일반적으로 두 개의 퀴리를 날려 합치는 것은 비용이 든다. 가능하면 \$in을 \$or보다 먼저 고려하는 것이 좋다.

인덱스를 걸면 안되는 경우
-
당연한 상식이지만 카디널리티가 낮은 경우, 즉 결과값이 많다면 걸지 않는 것이 좋다.

인덱스의 타입
-
Unique Indexes: _id 등에 걸리는 인덱스. 
Partial Indexes: 존재할 수도 있고, 아닐수도 있지만 존재한다면 유니크 해야하는 경우 patial 옵션을 사용할 수 있다.
